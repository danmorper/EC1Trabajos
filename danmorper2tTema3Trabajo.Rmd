---
title: "danmorper2TrabajoTema3"
author: "DanielMorenoPerez"
date: "2023-04-10"
output: html_document
---

# Librerías, y definiciones previas
Cargamos librerías
```{r}
library(KernSmooth)
```

Definimos la función de densidad real, rejilla de valores representativos de la v.a. Z y número de muestras y los tamaños de muestra
```{r}
# Función densidad real
real_dens <- function(x) {
  0.5 * dnorm(x, mean = -1.5) + 0.5 * dnorm(x, mean = 1.5)
}

# Creamos la rejilla de valores representativos de la v.a. Z
grid_size <- 512
grid_min <- -5
grid_max <- 5
grid <- seq(grid_min, grid_max, length = grid_size)

# Definimos el número de muestras y los tamaños de muestra
M <- 1000
ns <- c(50, 100)
```

# Métodos y simulación
Definimos los métodos. He escogido el método de los k vecinos más cercanos y el método de Sheather-Jones 
```{r}
method_I <- function(X,k) {
  dk=numeric(grid_size)
  for (i in 1:grid_size)
  {
    distancias=abs(grid[i]-X)
    dk[i]=distancias[which(rank(distancias)==k)]
  }
  fx=(k-1)/(2*n*dk)
  return(fx)
}


method_II <- function(X) {
  SJ <- density(X,bw="SJ")
  return(SJ)
}
```

Realizamos las simulaciones:
```{r}
# Realizamos las simulaciones ----
results <- data.frame(dato=c(), metodo = c(), tamaño = c(), parametro = c())
#cont = 0 lo usé para comprobar si me estaba corriendo el código
for (n in ns) {
  for (i in 1:M) {
    # Generamos la muestra X
    X <- 0.5*rnorm(n, mean = -1.5) + 0.5*rnorm(n, mean = 1.5)
    
    # Calculamos la densidad real
    real_density <- real_dens(grid)
    
    # Calculamos la densidad estimada con el método I
    for (k in c(15,30,50)) {
      h_I <- method_I(X, k)
      # Guardamos los resultados
      n_metodo <- length(h_I)
      esta_vuelta <- data.frame(dato = h_I, metodo = rep(1,n_metodo), tamaño = rep(n, n_metodo), parametro = rep(k, n_metodo))
      results <- rbind(results, esta_vuelta)
    }
    
    
    # Calculamos la densidad estimada con el método II
    h_II <- method_II(X)
    # Guardamos los resultados
    n_metodo <- length(h_II$y)
    esta_vuelta <- data.frame(dato = h_II$y, metodo = rep(2,n_metodo), tamaño = rep(n, n_metodo), parametro = rep("SJ", n_metodo))
    results <- rbind(results, esta_vuelta)
    
#    cont=cont + 1
#    print(cont)
  }
}
head(results)
```

# Escoger método según error cuadrático medio
Calculamos los errores cuadráticos medios para los distintos modelo y distintos tamaños. 

```{r}
#Función para calcular ECM
MSE <- function(dens_estimada, dens_real, grid) {
  mse <- sum((dens_estimada - dens_real)^2 * (grid[2]-grid[1]))
  return(mse)
}

# Sólo un parámetro (para usarlo en aggregate)
MSE_aggregate <- function(dens_estimada) {
  dens_real <- real_dens(grid)
  mse <- return(MSE(dens_estimada, dens_real, grid))
}

#Dataframe con los ECM
mse <- aggregate(results$dato, by = list(results$metodo, results$tamaño, results$parametro), FUN = MSE_aggregate)
names(mse) <- c("metodo", "tamaño", "parametro", "ECM")
mse
```

Veo cuál es el método y tamaño que minimiza el error cuadrático medio
```{r}
min_mse_row <- mse[which.min(mse$ECM), ];min_mse_row
```

```{r}
n <- min_mse_row$tamaño
X <- 0.5*rnorm(n, mean = -1.5) + 0.5*rnorm(n, mean = 1.5)
mejor_modelo <- method_II(X)
plot(x = mejor_modelo$x, y = mejor_modelo$y,type="l", xlab = "x", ylab = "y")
lines(grid,real_dens(grid),col="red",lwd=2)
```
```{r}
mse_k <- subset(mse, metodo ==1);mse_k
min_mse_row_k <- mse_k[which.min(mse_k$ECM), ];min_mse_row_k
```

```{r}
n <- min_mse_row_k$tamaño
X <- 0.5*rnorm(n, mean = -1.5) + 0.5*rnorm(n, mean = 1.5)
mejor_modelo_k <- method_I(X,min_mse_row_k$parametro);mejor_modelo_k
plot(seq(-5,5, length= length(mejor_modelo_k)), y = mejor_modelo_k,type="l", xlab = "x", ylab = "y")
lines(grid,real_dens(grid),col="red",lwd=2)
```